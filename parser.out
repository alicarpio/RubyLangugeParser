Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND_OP
    CASE
    CLASS
    CLASS_NAME
    COLON
    COMMENT
    DEF
    DIVIDE
    DO
    DOT
    EACH
    ELSE
    ELSIF
    END
    EQ
    FALSE
    FOR
    GE
    GT
    HASHROCKET
    IF
    INITIALIZE
    LBRACKET
    LE
    LPAREN
    LSQBRACKET
    LT
    MINUS
    MODULE
    MULTIPLY
    NE
    NEW
    NOT_OP
    NULL
    OR_OP
    PIPE
    PLUS
    POWER
    RBRACKET
    RPAREN
    RSQBRACKET
    SEMICOLON
    SYMBOL
    TRUE
    UNLESS
    UNTIL
    VARIABLE_CLASE
    VARIABLE_CONSTANTE
    VARIABLE_GLOBAL
    VARIABLE_INSTANCIA
    VARIABLE_LOCAL
    WHEN
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> code
Rule 2     program -> code program
Rule 3     code -> asignacion
Rule 4     code -> impresion
Rule 5     asignacion -> NAME EQUALS valor
Rule 6     impresion -> PUTS argumentos_opt
Rule 7     argumentos_opt -> argumentos
Rule 8     argumentos_opt -> empty
Rule 9     argumentos -> valor
Rule 10    argumentos -> valor COMA argumentos
Rule 11    valor -> STRING
Rule 12    valor -> INTEGER
Rule 13    valor -> FLOAT
Rule 14    valor -> NAME
Rule 15    empty -> <empty>

Terminals, with rules where they appear

AND_OP               : 
CASE                 : 
CLASS                : 
CLASS_NAME           : 
COLON                : 
COMA                 : 10
COMMENT              : 
DEF                  : 
DIVIDE               : 
DO                   : 
DOT                  : 
EACH                 : 
ELSE                 : 
ELSIF                : 
END                  : 
EQ                   : 
EQUALS               : 5
FALSE                : 
FLOAT                : 13
FOR                  : 
GE                   : 
GT                   : 
HASHROCKET           : 
IF                   : 
INITIALIZE           : 
INTEGER              : 12
LBRACKET             : 
LE                   : 
LPAREN               : 
LSQBRACKET           : 
LT                   : 
MINUS                : 
MODULE               : 
MULTIPLY             : 
NAME                 : 5 14
NE                   : 
NEW                  : 
NOT_OP               : 
NULL                 : 
OR_OP                : 
PIPE                 : 
PLUS                 : 
POWER                : 
PUTS                 : 6
RBRACKET             : 
RPAREN               : 
RSQBRACKET           : 
SEMICOLON            : 
STRING               : 11
SYMBOL               : 
TRUE                 : 
UNLESS               : 
UNTIL                : 
VARIABLE_CLASE       : 
VARIABLE_CONSTANTE   : 
VARIABLE_GLOBAL      : 
VARIABLE_INSTANCIA   : 
VARIABLE_LOCAL       : 
WHEN                 : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

argumentos           : 7 10
argumentos_opt       : 6
asignacion           : 3
code                 : 1 2
empty                : 8
impresion            : 4
program              : 2 0
valor                : 5 9 10

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . code
    (2) program -> . code program
    (3) code -> . asignacion
    (4) code -> . impresion
    (5) asignacion -> . NAME EQUALS valor
    (6) impresion -> . PUTS argumentos_opt

    NAME            shift and go to state 5
    PUTS            shift and go to state 6

    program                        shift and go to state 1
    code                           shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> code .
    (2) program -> code . program
    (1) program -> . code
    (2) program -> . code program
    (3) code -> . asignacion
    (4) code -> . impresion
    (5) asignacion -> . NAME EQUALS valor
    (6) impresion -> . PUTS argumentos_opt

    $end            reduce using rule 1 (program -> code .)
    NAME            shift and go to state 5
    PUTS            shift and go to state 6

    code                           shift and go to state 2
    program                        shift and go to state 7
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4

state 3

    (3) code -> asignacion .

    NAME            reduce using rule 3 (code -> asignacion .)
    PUTS            reduce using rule 3 (code -> asignacion .)
    $end            reduce using rule 3 (code -> asignacion .)


state 4

    (4) code -> impresion .

    NAME            reduce using rule 4 (code -> impresion .)
    PUTS            reduce using rule 4 (code -> impresion .)
    $end            reduce using rule 4 (code -> impresion .)


state 5

    (5) asignacion -> NAME . EQUALS valor

    EQUALS          shift and go to state 8


state 6

    (6) impresion -> PUTS . argumentos_opt
    (7) argumentos_opt -> . argumentos
    (8) argumentos_opt -> . empty
    (9) argumentos -> . valor
    (10) argumentos -> . valor COMA argumentos
    (15) empty -> .
    (11) valor -> . STRING
    (12) valor -> . INTEGER
    (13) valor -> . FLOAT
    (14) valor -> . NAME

  ! shift/reduce conflict for NAME resolved as shift
    PUTS            reduce using rule 15 (empty -> .)
    $end            reduce using rule 15 (empty -> .)
    STRING          shift and go to state 13
    INTEGER         shift and go to state 14
    FLOAT           shift and go to state 15
    NAME            shift and go to state 16

  ! NAME            [ reduce using rule 15 (empty -> .) ]

    argumentos_opt                 shift and go to state 9
    argumentos                     shift and go to state 10
    empty                          shift and go to state 11
    valor                          shift and go to state 12

state 7

    (2) program -> code program .

    $end            reduce using rule 2 (program -> code program .)


state 8

    (5) asignacion -> NAME EQUALS . valor
    (11) valor -> . STRING
    (12) valor -> . INTEGER
    (13) valor -> . FLOAT
    (14) valor -> . NAME

    STRING          shift and go to state 13
    INTEGER         shift and go to state 14
    FLOAT           shift and go to state 15
    NAME            shift and go to state 16

    valor                          shift and go to state 17

state 9

    (6) impresion -> PUTS argumentos_opt .

    NAME            reduce using rule 6 (impresion -> PUTS argumentos_opt .)
    PUTS            reduce using rule 6 (impresion -> PUTS argumentos_opt .)
    $end            reduce using rule 6 (impresion -> PUTS argumentos_opt .)


state 10

    (7) argumentos_opt -> argumentos .

    NAME            reduce using rule 7 (argumentos_opt -> argumentos .)
    PUTS            reduce using rule 7 (argumentos_opt -> argumentos .)
    $end            reduce using rule 7 (argumentos_opt -> argumentos .)


state 11

    (8) argumentos_opt -> empty .

    NAME            reduce using rule 8 (argumentos_opt -> empty .)
    PUTS            reduce using rule 8 (argumentos_opt -> empty .)
    $end            reduce using rule 8 (argumentos_opt -> empty .)


state 12

    (9) argumentos -> valor .
    (10) argumentos -> valor . COMA argumentos

    NAME            reduce using rule 9 (argumentos -> valor .)
    PUTS            reduce using rule 9 (argumentos -> valor .)
    $end            reduce using rule 9 (argumentos -> valor .)
    COMA            shift and go to state 18


state 13

    (11) valor -> STRING .

    COMA            reduce using rule 11 (valor -> STRING .)
    NAME            reduce using rule 11 (valor -> STRING .)
    PUTS            reduce using rule 11 (valor -> STRING .)
    $end            reduce using rule 11 (valor -> STRING .)


state 14

    (12) valor -> INTEGER .

    COMA            reduce using rule 12 (valor -> INTEGER .)
    NAME            reduce using rule 12 (valor -> INTEGER .)
    PUTS            reduce using rule 12 (valor -> INTEGER .)
    $end            reduce using rule 12 (valor -> INTEGER .)


state 15

    (13) valor -> FLOAT .

    COMA            reduce using rule 13 (valor -> FLOAT .)
    NAME            reduce using rule 13 (valor -> FLOAT .)
    PUTS            reduce using rule 13 (valor -> FLOAT .)
    $end            reduce using rule 13 (valor -> FLOAT .)


state 16

    (14) valor -> NAME .

    COMA            reduce using rule 14 (valor -> NAME .)
    NAME            reduce using rule 14 (valor -> NAME .)
    PUTS            reduce using rule 14 (valor -> NAME .)
    $end            reduce using rule 14 (valor -> NAME .)


state 17

    (5) asignacion -> NAME EQUALS valor .

    NAME            reduce using rule 5 (asignacion -> NAME EQUALS valor .)
    PUTS            reduce using rule 5 (asignacion -> NAME EQUALS valor .)
    $end            reduce using rule 5 (asignacion -> NAME EQUALS valor .)


state 18

    (10) argumentos -> valor COMA . argumentos
    (9) argumentos -> . valor
    (10) argumentos -> . valor COMA argumentos
    (11) valor -> . STRING
    (12) valor -> . INTEGER
    (13) valor -> . FLOAT
    (14) valor -> . NAME

    STRING          shift and go to state 13
    INTEGER         shift and go to state 14
    FLOAT           shift and go to state 15
    NAME            shift and go to state 16

    valor                          shift and go to state 12
    argumentos                     shift and go to state 19

state 19

    (10) argumentos -> valor COMA argumentos .

    NAME            reduce using rule 10 (argumentos -> valor COMA argumentos .)
    PUTS            reduce using rule 10 (argumentos -> valor COMA argumentos .)
    $end            reduce using rule 10 (argumentos -> valor COMA argumentos .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NAME in state 6 resolved as shift
